#!/usr/bin/env python
#
# Copyright 2017
# Johannes K. Fichte, TU Wien, Austria
#
# fhtw_checker.py is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.  fhtw_checker.py is distributed in
# the hope that it will be useful, but WITHOUT ANY WARRANTY; without
# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.  You should have received a copy of the GNU General Public
# License along with fhtw_checker.py.  If not, see
# <http://www.gnu.org/licenses/>.

# from __future__ import absolute_import, print_function
from __future__ import absolute_import

import argparse
import logging
import logging.config
import inspect
import os
import sys

# TODO: figure out a new way to use imports for binaries here
# this just seems really really ugly
src_path = os.path.abspath(os.path.realpath(inspect.getfile(inspect.currentframe())))
src_path = os.path.realpath(os.path.join(src_path, '../..'))

if src_path not in sys.path:
    sys.path.insert(0, src_path)

import decomp_validate

__author__ = 'Johannes K. Fichte & Markus Hecher'
__license__ = 'GPL'
__version__ = '1.0.1-dev'


def setup_logging(config_file='%s/logging.conf' % (os.path.dirname(__file__))):
    logging.config.fileConfig(config_file)


setup_logging(os.path.join(os.path.dirname(os.path.realpath(__file__)), 'logging.conf'))


def is_valid_file(parser, arg):
    if not arg:
        parser.error('Missing file.')
    if not os.path.exists(arg):
        parser.error('The file "%s" does not exist!' % arg)


def names(x):
    return map(lambda x: "%s" % x.__name__, x)


available_validators = [decomp_validate.validators.TreeDecompositionValidator,
                        decomp_validate.validators.GeneralizedHypertreeDecompositionValidator
                        #                         decomp_validate.validators.HyperDecomposition,
                        #                         decomp_validate.validators.GeneralizedHyperDecomposition,
                        #                        decomp_validate.validators.FractionalHyperDecomposition
                        ]

#TODO: implement short names for ghtw validator

def parse_args():
    parser = argparse.ArgumentParser(description='%(prog)s -f instance')
    parser.add_argument('--version', action='version', version='%(prog)s {version}'.format(version=__version__))
    parser.add_argument('-g', '--hypergraph', dest='graph_filename', action='store', type=lambda x: os.path.realpath(x),
                        help='Input dimacs hypergraph file')
    parser.add_argument('-d', '--decomposition', dest='decomposition_filename', action='store',
                        type=lambda x: os.path.realpath(x), help='Input decomposition file')
    parser.add_argument('-t', '--type', dest='validator', action='store', type=str, help='Type of the Decomposition',
                        choices=names(available_validators),
                        default=decomp_validate.validators.TreeDecompositionValidator.__name__)
    args = parser.parse_args()
    return args


def main():
    args = parse_args()
    validator_class_name = args.validator
    graph_filename = args.graph_filename
    decomposition_filename = args.decomposition_filename
    print validator_class_name
    Validator = getattr(decomp_validate.validators, validator_class_name)()

    #TODO: implement read header to guess decomposition type and remove it from the commandline arguments

    #TODO: next for hypertree decompositions
    #TODO: generalized hypertree decompositions
    #TODO:  fractional hyper decompositions
    HG = getattr(decomp_validate.utils,Validator.graph_type()).from_file(graph_filename)
    Decomp = getattr(decomp_validate.decompositions,Validator.decomposition_type()).from_file(decomposition_filename)
    ret=Decomp.validate(HG)
    exit(not ret)


if __name__ == "__main__":
    main()
